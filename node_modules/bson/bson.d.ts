/**
 * A class representation of the BSON Binary type.
 * @public
 * @category BSONType
 */
export declare class Binary extends BSONValue {
    get _bsontype(): 'Binary';
    /* Excluded from this release type: BSON_BINARY_SUBTYPE_DEFAULT */
    /** Initial buffer default size */
    static readonly BUFFER_SIZE = 256;
    /** Default BSON type */
    static readonly SUBTYPE_DEFAULT = 0;
    /** Function BSON type */
    static readonly SUBTYPE_FUNCTION = 1;
    /**
     * Legacy default BSON Binary type
     * @deprecated BSON Binary subtype 2 is deprecated in the BSON specification
     */
    static readonly SUBTYPE_BYTE_ARRAY = 2;
    /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */
    static readonly SUBTYPE_UUID_OLD = 3;
    /** UUID BSON type */
    static readonly SUBTYPE_UUID = 4;
    /** MD5 BSON type */
    static readonly SUBTYPE_MD5 = 5;
    /** Encrypted BSON type */
    static readonly SUBTYPE_ENCRYPTED = 6;
    /** Column BSON type */
    static readonly SUBTYPE_COLUMN = 7;
    /** Sensitive BSON type */
    static readonly SUBTYPE_SENSITIVE = 8;
    /** Vector BSON type */
    static readonly SUBTYPE_VECTOR = 9;
    /** User BSON type */
    static readonly SUBTYPE_USER_DEFINED = 128;
    /** datatype of a Binary Vector (subtype: 9) */
    static readonly VECTOR_TYPE: Readonly<{
        readonly Int8: 3;
        readonly Float32: 39;
        readonly PackedBit: 16;
    }>;
    /**
     * The bytes of the Binary value.
     *
     * The format of a Binary value in BSON is defined as:
     * ```txt
     * binary	::= int32 subtype (byte*)
     * ```
     *
     * This `buffer` is the "(byte*)" segment.
     *
     * Unless the value is subtype 2, then deserialize will read the first 4 bytes as an int32 and set this to the remaining bytes.
     *
     * ```txt
     * binary	::= int32 unsigned_byte(2) int32 (byte*)
     * ```
     *
     * @see https://bsonspec.org/spec.html
     */
    buffer: Uint8Array;
    /**
     * The binary subtype.
     *
     * Current defined values are:
     *
     * - `unsigned_byte(0)` Generic binary subtype
     * - `unsigned_byte(1)` Function
     * - `unsigned_byte(2)` Binary (Deprecated)
     * - `unsigned_byte(3)` UUID (Deprecated)
     * - `unsigned_byte(4)` UUID
     * - `unsigned_byte(5)` MD5
     * - `unsigned_byte(6)` Encrypted BSON value
     * - `unsigned_byte(7)` Compressed BSON column
     * - `unsigned_byte(8)` Sensitive
     * - `unsigned_byte(9)` Vector
     * - `unsigned_byte(128)` - `unsigned_byte(255)` User defined
     */
    sub_type: number;
    /**
     * The Binary's `buffer` can be larger than the Binary's content.
     * This property is used to determine where the content ends in the buffer.
     */
    position: number;
    /**
     * Create a new Binary instance.
     * @param buffer - a buffer object containing the binary data.
     * @param subType - the option binary type.
     */
    constructor(buffer?: BinarySequence, subType?: number);
    /**
     * Updates this binary with byte_value.
     *
     * @param byteValue - a single byte we wish to write.
     */
    put(byteValue: string | number | Uint8Array | number[]): void;
    /**
     * Writes a buffer to the binary.
     *
     * @param sequence - a string or buffer to be written to the Binary BSON object.
     * @param offset - specify the binary of where to write the content.
     */
    write(sequence: BinarySequence, offset: number): void;
    /**
     * Returns a view of **length** bytes starting at **position**.
     *
     * @param position - read from the given position in the Binary.
     * @param length - the number of bytes to read.
     */
    read(position: number, length: number): Uint8Array;
    /** returns a view of the binary value as a Uint8Array */
    value(): Uint8Array;
    /** the length of the binary sequence */
    length(): number;
    toJSON(): string;
    toString(encoding?: 'hex' | 'base64' | 'utf8' | 'utf-8'): string;
    /* Excluded from this release type: toExtendedJSON */
    toUUID(): UUID;
    /** Creates an Binary instance from a hex digit string */
    static createFromHexString(hex: string, subType?: number): Binary;
    /** Creates an Binary instance from a base64 string */
    static createFromBase64(base64: string, subType?: number): Binary;
    /* Excluded from this release type: fromExtendedJSON */
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
    /**
     * If this Binary represents a Int8 Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.Int8`),
     * returns a copy of the bytes in a new Int8Array.
     *
     * If the Binary is not a Vector, or the datatype is not Int8, an error is thrown.
     */
    toInt8Array(): Int8Array;
    /**
     * If this Binary represents a Float32 Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.Float32`),
     * returns a copy of the bytes in a new Float32Array.
     *
     * If the Binary is not a Vector, or the datatype is not Float32, an error is thrown.
     */
    toFloat32Array(): Float32Array;
    /**
     * If this Binary represents packed bit Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.PackedBit`),
     * returns a copy of the bytes that are packed bits.
     *
     * Use `toBits` to get the unpacked bits.
     *
     * If the Binary is not a Vector, or the datatype is not PackedBit, an error is thrown.
     */
    toPackedBits(): Uint8Array;
    /**
     * If this Binary represents a Packed bit Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.PackedBit`),
     * returns a copy of the bit unpacked into a new Int8Array.
     *
     * Use `toPackedBits` to get the bits still in packed form.
     *
     * If the Binary is not a Vector, or the datatype is not PackedBit, an error is thrown.
     */
    toBits(): Int8Array;
    /**
     * Constructs a Binary representing an Int8 Vector.
     * @param array - The array to store as a view on the Binary class
     */
    static fromInt8Array(array: Int8Array): Binary;
    /** Constructs a Binary representing an Float32 Vector. */
    static fromFloat32Array(array: Float32Array): Binary;
    /**
     * Constructs a Binary representing a packed bit Vector.
     *
     * Use `fromBits` to pack an array of 1s and 0s.
     */
    static fromPackedBits(array: Uint8Array, padding?: number): Binary;
    /**
     * Constructs a Binary representing an Packed Bit Vector.
     * @param array - The array of 1s and 0s to pack into the Binary instance
     */
    static fromBits(bits: ArrayLike<number>): Binary;
}

/** @public */
export declare interface BinaryExtended {
    $binary: {
        subType: string;
        base64: string;
    };
}

/** @public */
export declare interface BinaryExtendedLegacy {
    $type: string;
    $binary: string;
}

/** @public */
export declare type BinarySequence = Uint8Array | number[];

declare namespace BSON {
    export {
        setInternalBufferSize,
        serialize,
        serializeWithBufferAndIndex,
        deserialize,
        calculateObjectSize,
        deserializeStream,
        UUIDExtended,
        BinaryExtended,
        BinaryExtendedLegacy,
        BinarySequence,
        CodeExtended,
        DBRefLike,
        Decimal128Extended,
        DoubleExtended,
        EJSONOptions,
        Int32Extended,
        LongExtended,
        MaxKeyExtended,
        MinKeyExtended,
        ObjectIdExtended,
        ObjectIdLike,
        BSONRegExpExtended,
        BSONRegExpExtendedLegacy,
        BSONSymbolExtended,
        LongWithoutOverrides,
        TimestampExtended,
        TimestampOverrides,
        LongWithoutOverridesClass,
        SerializeOptions,
        DeserializeOptions,
        Code,
        BSONSymbol,
        DBRef,
        Binary,
        ObjectId,
        UUID,
        Long,
        Timestamp,
        Double,
        Int32,
        MinKey,
        MaxKey,
        BSONRegExp,
        Decimal128,
        BSONValue,
        bsonType,
        BSONTypeTag,
        BSONError,
        BSONVersionError,
        BSONRuntimeError,
        BSONOffsetError,
        BSONType,
        EJSON,
        onDemand,
        OnDemand,
        Document,
        CalculateObjectSizeOptions
    }
}
export { BSON }

/* Excluded from this release type: BSON_MAJOR_VERSION */

/* Excluded from this release type: BSON_VERSION_SYMBOL */

/**
 * @public
 * @experimental
 */
declare type BSONElement = [
type: number,
nameOffset: number,
nameLength: number,
offset: number,
length: number
];

/**
 * @public
 * @category Error
 *
 * `BSONError` objects are thrown when BSON encounters an error.
 *
 * This is the parent class for all the other errors thrown by this library.
 */
export declare class BSONError extends Error {
    /* Excluded from this release type: bsonError */
    get name(): string;
    constructor(message: string, options?: {
        cause?: unknown;
    });
    /**
     * @public
     *
     * All errors thrown from the BSON library inherit from `BSONError`.
     * This method can assist with determining if an error originates from the BSON library
     * even if it does not pass an `instanceof` check against this class' constructor.
     *
     * @param value - any javascript value that needs type checking
     */
    static isBSONError(value: unknown): value is BSONError;
}

/**
 * @public
 * @category Error
 *
 * @experimental
 *
 * An error generated when BSON bytes are invalid.
 * Reports the offset the parser was able to reach before encountering the error.
 */
export declare class BSONOffsetError extends BSONError {
    get name(): 'BSONOffsetError';
    offset: number;
    constructor(message: string, offset: number, options?: {
        cause?: unknown;
    });
}

/**
 * A class representation of the BSON RegExp type.
 * @public
 * @category BSONType
 */
export declare class BSONRegExp extends BSONValue {
    get _bsontype(): 'BSONRegExp';
    pattern: string;
    options: string;
    /**
     * @param pattern - The regular expression pattern to match
     * @param options - The regular expression options
     */
    constructor(pattern: string, options?: string);
    static parseOptions(options?: string): string;
    /* Excluded from this release type: toExtendedJSON */
    /* Excluded from this release type: fromExtendedJSON */
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}

/** @public */
export declare interface BSONRegExpExtended {
    $regularExpression: {
        pattern: string;
        options: string;
    };
}

/** @public */
export declare interface BSONRegExpExtendedLegacy {
    $regex: string | BSONRegExp;
    $options: string;
}

/**
 * @public
 * @category Error
 *
 * An error generated when BSON functions encounter an unexpected input
 * or reaches an unexpected/invalid internal state
 *
 */
export declare class BSONRuntimeError extends BSONError {
    get name(): 'BSONRuntimeError';
    constructor(message: string);
}

/**
 * A class representation of the BSON Symbol type.
 * @public
 * @category BSONType
 */
export declare class BSONSymbol extends BSONValue {
    get _bsontype(): 'BSONSymbol';
    value: string;
    /**
     * @param value - the string representing the symbol.
     */
    constructor(value: string);
    /** Access the wrapped string value. */
    valueOf(): string;
    toString(): string;
    toJSON(): string;
    /* Excluded from this release type: toExtendedJSON */
    /* Excluded from this release type: fromExtendedJSON */
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}

/** @public */
export declare interface BSONSymbolExtended {
    $symbol: string;
}

/** @public */
export declare const BSONType: Readonly<{
    readonly double: 1;
    readonly string: 2;
    readonly object: 3;
    readonly array: 4;
    readonly binData: 5;
    readonly undefined: 6;
    readonly objectId: 7;
    readonly bool: 8;
    readonly date: 9;
    readonly null: 10;
    readonly regex: 11;
    readonly dbPointer: 12;
    readonly javascript: 13;
    readonly symbol: 14;
    readonly javascriptWithScope: 15;
    readonly int: 16;
    readonly timestamp: 17;
    readonly long: 18;
    readonly decimal: 19;
    readonly minKey: -1;
    readonly maxKey: 127;
}>;

/** @public */
export declare type BSONType = (typeof BSONType)[keyof typeof BSONType];

/** @public */
export declare const bsonType: unique symbol;

/** @public */
export declare type BSONTypeTag = 'BSONRegExp' | 'BSONSymbol' | 'ObjectId' | 'Binary' | 'Decimal128' | 'Double' | 'Int32' | 'Long' | 'MaxKey' | 'MinKey' | 'Timestamp' | 'Code' | 'DBRef';

/** @public */
export declare abstract class BSONValue {
    /** @public */
    abstract get _bsontype(): BSONTypeTag;
    get [bsonType](): this['_bsontype'];
    /* Excluded from this release type: [BSON_VERSION_SYMBOL] */
 